{
    "Priority Queue": {
        "scope": "go",
        "description": "グラフの実装",
        "prefix": ["graph"],
        "body": [
            "// Graph はグラフを表現する構造です",
            "type Graph struct {",
            "    // 隣接リスト",
            "    list [][]Edge",
            "}",
            "",
            "// Edge は辺を表現する構造体です",
            "type Edge struct {",
            "    to     int",
            "    weight int",
            "}",
            "",
            "// NewGraph はグラフを作成します",
            "func NewGraph(n int) *Graph {",
            "    return &(Graph { make([][]Edge, n) })",
            "}",
            "// AddEdge は辺を追加します",
            "func (g *Graph) AddEdge(s, t int) {",
            "    g.AddWeightedEdge(s, t, 1)",
            "}",
            "",
            "// AddWeightedEdge は重み付きの辺を追加します。",
            "func (g *Graph) AddWEightedEdge(s, t, w int) {",
            "    g.list[s] = append(g.list[s], Edge{ t, w }",
            "}",
            "",
            "// Dijkstra はsからtへの最短距離と最短ルートを返します。",
            "// 重みが負の辺があるときには使用できません。",
            "// 計算量: (|V| + |E|)log|V|",
            "func (g *Graph) Dijkstra(s, t int) int, []int {",
            "}",
            "// BellmanFord はsからtへの最短ルートを返します。",
            "func (g *Graph) BellmanFord(s, t int) {",
            "}",
            "",
            "// WarshallFloyd は全点対の最短ルートを返します。",
            "func (g *Graph) WarshallFloyd() [][]int {",
            "    INF := math.MaxInt64",
            "    n := len(g.list)",
            "    d := make([][]int, n)",
            "    for i := 0; i < n; i++ {",
            "        d[i] = make([]int, n)",
            "        for j := 0; j < n; j++ {",
            "            if i == j {",
            "                d[i][j] = 0",
            "            } else {",
            "                d[i][j] = INF",
            "            }",
            "        }",
            "        for j := 0; j < len(g.list[i]); j++ {",
            "            d[i][g.list[i][j]] = ",
            "        }",
            "    }",
            "",
            "    for k := 0; k < n; k++ {",
            "        for i := 0; i < n; i++ {",
            "            for j := 0; j < n; j++ {",
            "                d[i][j] = min(d[i][j], d[i][k] + d[k][j])",
            "            }",
            "        }",
            "    }",
            "",
            "    return d",
            "}",
            "",
            "// Dinic はsからtへの最小費用流を返します。",
            "",
            "",
        ]
    }
}
