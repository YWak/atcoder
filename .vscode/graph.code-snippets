{
    "Priority Queue": {
        "scope": "go",
        "description": "グラフの実装",
        "prefix": ["_graph"],
        "body": [
            "// Graph はグラフを表現する構造です",
            "type Graph struct {",
            "    // 隣接リスト",
            "    list [][]Edge",
            "}",
            "",
            "// Edge は辺を表現する構造体です",
            "type Edge struct {",
            "    to     int",
            "    weight int",
            "}",
            "",
            "// NewGraph はグラフを作成します",
            "func NewGraph(n int) *Graph {",
            "    return &(Graph { make([][]Edge, n) })",
            "}",
            "// AddEdge は辺を追加します",
            "func (g *Graph) AddEdge(s, t int) {",
            "    g.AddWeightedEdge(s, t, 1)",
            "}",
            "",
            "// AddWeightedEdge は重み付きの辺を追加します。",
            "func (g *Graph) AddWeightedEdge(s, t, w int) {",
            "    g.list[s] = append(g.list[s], Edge{ t, w })",
            "}",
            "",
            "// DijkstraNode は ダイクストラ法を使用するときに使うノード",
            "type DijkstraNode struct {",
            "    node int",
            "    cost int",
            "}",
            "// DijkstraPriorityQueue はダイクストラ法を使用するときに使う優先度付きキュー",
            "type DijkstraPriorityQueue []*DijkstraNode",
            "",
            "func (pq DijkstraPriorityQueue) Len() int           { return len(pq) }",
            "func (pq DijkstraPriorityQueue) Less(i, j int) bool { return pq[i].cost < pq[j].cost }",
            "func (pq DijkstraPriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }",
            "// Push はpqに要素を追加する",
            "func (pq *DijkstraPriorityQueue) Push(x interface{}) { *pq = append(*pq, x.(*DijkstraNode)) }",
            "// Pop はpqから要素を取得する",
            "func (pq *DijkstraPriorityQueue) Pop() interface{} {",
            "    o := *pq",
            "    n := len(o) - 1",
            "    item := o[n]",
            "    *pq = o[0:n]",
            "    return item",
            "}",
            "// Dijkstra はsからtへの最短距離を返します。",
            "// 重みが負の辺があるときには使用できません。",
            "// 計算量: |V| + |E|log|V|",
            "func (g *Graph) Dijkstra(s, t int) int {",
            "    n := len(g.list)",
            "    pq := make(DijkstraPriorityQueue, 0)",
            "    cost := make([]int, n)",
            "    for i := 0; i < n; i++ {",
            "        var c int",
            "        if i == s {",
            "            c = 0",
            "        } else {",
            "            c = INF18",
            "        }",
            "        cost[i] = c",
            "        heap.Push(&pq, &DijkstraNode{i, c})",
            "    }",
            "",
            "    for pq.Len() > 0 {",
            "        u := heap.Pop(&pq).(*DijkstraNode)",
            "        if u.node == t {",
            "            break",
            "        }",
            "        for i := 0; i < len(g.list[u.node]); i++ {",
            "            v := g.list[u.node][i]",
            "            c := cost[u.node] + v.weight",
            "            if cost[v.to] > c {",
            "                cost[v.to] = c",
            "                heap.Push(&pq, &DijkstraNode{v.to, c})",
            "            }",
            "        }",
            "    }",
            "",
            "    return cost[t]",
            "}",
            "// DijkstraAll はsから全点への最短距離を返します。",
            "// 重みが負の辺があるときには使用できません。",
            "// 計算量: |V| + |E|log|V|",
            "func (g *Graph) DijkstraAll(s int) []int {",
            "    n := len(g.list)",
            "    pq := make(DijkstraPriorityQueue, 0)",
            "    cost := make([]int, n)",
            "    for i := 0; i < n; i++ {",
            "        var c int",
            "        if i == s {",
            "            c = 0",
            "        } else {",
            "            c = INF18",
            "        }",
            "        cost[i] = c",
            "        heap.Push(&pq, &DijkstraNode{i, c})",
            "    }",
            "",
            "    for pq.Len() > 0 {",
            "        u := heap.Pop(&pq).(*DijkstraNode)",
            "        for i := 0; i < len(g.list[u.node]); i++ {",
            "            v := g.list[u.node][i]",
            "            c := cost[u.node] + v.weight",
            "            if cost[v.to] > c {",
            "                cost[v.to] = c",
            "                heap.Push(&pq, &DijkstraNode{v.to, c})",
            "            }",
            "        }",
            "    }",
            "",
            "    return cost",
            "}",
            "// BellmanFord はsからtへの最短ルートを返します。",
            "func (g *Graph) BellmanFord(s, t int) {",
            "}",
            "",
            "// WarshallFloyd は全点対の最短ルートを返します。",
            "func (g *Graph) WarshallFloyd() [][]int {",
            "    n := len(g.list)",
            "    d := make([][]int, n)",
            "    for i := 0; i < n; i++ {",
            "        d[i] = make([]int, n)",
            "        for j := 0; j < n; j++ {",
            "            if i == j {",
            "                d[i][j] = 0",
            "            } else {",
            "                d[i][j] = INF18",
            "            }",
            "        }",
            "        for j := 0; j < len(g.list[i]); j++ {",
            "            k := g.list[i][j]",
            "            d[i][k.to] = k.weight",
            "        }",
            "    }",
            "",
            "    for k := 0; k < n; k++ {",
            "        for i := 0; i < n; i++ {",
            "            for j := 0; j < n; j++ {",
            "                d[i][j] = min(d[i][j], d[i][k] + d[k][j])",
            "            }",
            "        }",
            "    }",
            "",
            "    return d",
            "}",
            "",
//            "// Dinic はsからtへの最大流を返します。",
            "",
            "",
        ]
    },
    "scc": {
        "prefix": "_scc",
        "description": "強連結成分分解の実装",
        "scope": "go",
        "body": [
            "// Sccは強連結成分分解の結果を表します。",
            "type Scc struct {",
            "  // nは強連結成分分解後の頂点数",
            "  n          int",
            "  // graphは強連結成分分解後のグラフ",
            "  graph      [][]int",
            "  // componentsは強連結成分分解後の頂点(0-indexed)と、その頂点に対応する、もとのグラフの頂点(0-indexed)の配列",
            "  components [][]int",
            "  // nodesはもとのグラフの頂点(0-indexed)と、対応する新しい頂点(0-indexed)",
            "  nodes      map[int]int",
            "}",
            "",
            "// sccは与えられたグラフgを強連結成分分解した結果を返します。",
            "func scc(g [][]int) Scc {",
            "  s := Scc{",
            "    nodes: map[int]int{},",
            "  }",
            "",
            "  // 逆向きのグラフを作る",
            "  rg := make([][]int, len(g))",
            "  for u, l := range g {",
            "    for _, v := range l {",
            "      rg[v] = append(rg[v], u)",
            "    }",
            "  }",
            "",
            "  used := make([]bool, len(g))",
            "  order := make([]int, 0, len(g))",
            "",
            "  // 帰りがけ順に順序を保存するdfs",
            "  var dfs func(u int)",
            "  dfs = func(u int) {",
            "    used[u] = true",
            "    for _, v := range g[u] {",
            "      if !used[v] {",
            "        dfs(v)",
            "      }",
            "    }",
            "    order = append(order, u)",
            "  }",
            "  for i := 0; i < len(g); i++ {",
            "    if !used[i] {",
            "      dfs(i)",
            "    }",
            "  }",
            "",
            "  // 逆向きにたどって採番する",
            "  var rdfs func(u, k int)",
            "  rdfs = func(u, k int) {",
            "    s.nodes[u] = k",
            "    for _, v := range rg[u] {",
            "      if _, e := s.nodes[v]; !e {",
            "        rdfs(v, k)",
            "      }",
            "    }",
            "  }",
            "  for i := len(order) - 1; i >= 0; i-- {",
            "    u := order[i]",
            "    if _, e := s.nodes[u]; !e {",
            "      rdfs(u, s.n)",
            "      s.n++",
            "    }",
            "  }",
            "",
            "  // nodesをもとにしてcomponentsを作成する",
            "  s.components = make([][]int, s.n)",
            "  for from, to := range s.nodes {",
            "    s.components[to] = append(s.components[to], from)",
            "  }",
            "",
            "  type p struct {",
            "    u, v int",
            "  }",
            "",
            "  // 強連結成分分解後のグラフを作成する",
            "  connected := map[p]bool{}",
            "  s.graph = make([][]int, s.n)",
            "  for u, l := range g {",
            "    for _, v := range l {",
            "      if s.nodes[u] != s.nodes[v] && !connected[p{u, v}] {",
            "        connected[p{u, v}] = true",
            "        s.graph[s.nodes[u]] = append(s.graph[s.nodes[u]], s.nodes[v])",
            "      }",
            "    }",
            "  }",
            "",
            "  return s",
            "}"
        ]
    }
}
