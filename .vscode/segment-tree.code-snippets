{
    "segment tree / point update range query": {
        "scope": "go",
        "description": "セグメント木。一点更新、区間取得を効率よくおこなうデータ構造。",
        "prefix": ["_segmenttree"],
        "body": [
            "type SegmentTreeFunctions struct {",
            "    // 単位元を返します",
            "    e func() int",
            "    // 計算結果を返します",
            "    calc func(a, b int) int",
            "}",
            "",
            "type SegmentTree struct {",
            "    // このsegment treeが管理するインデックスの範囲。[0, n)を管理する。",
            "    n int",
            "",
            "    // segment treeの各ノードの値を保持する配列",
            "    nodes []int",
            "",
            "    // このsegment treeの値を操作する関数群",
            "    f SegmentTreeFunctions",
            "}",
            "",
            "// NewSegmentTreeは区間和を扱うSegmentTreeを返します。",
            "// tested:",
            "//   https://atcoder.jp/contests/abl/tasks/abl_d",
            "func NewSegmentTree() *SegmentTree {",
            "    return &SegmentTree{",
            "        -1,",
            "        []int{},",
            "        SegmentTreeFunctions{",
            "            func() int { return 0 },",
            "            func(a, b int) int { return a + b },",
            "        },",
            "    }",
            "}",
            "",
            "// NewRangeMaxQueryは区間最大値を扱うSegmentTreeを返します。",
            "func NewRangeMaxQuery() *SegmentTree {",
            "    return &SegmentTree{",
            "        -1,",
            "        []int{},",
            "        SegmentTreeFunctions{",
            "            func() int { return 0 },",
            "            func(a, b int) int { return max(a, b) },",
            "        },",
            "    }",
            "}",
            "",
            "// NewRangeMinQueryは区間最小値を扱うSegmentTreeを返します。",
            "// tested:",
            "//   https://judge.yosupo.jp/problem/staticrmq",
            "func NewRangeMinQuery() *SegmentTree {",
            "    return &SegmentTree{",
            "        -1,",
            "        []int{},",
            "        SegmentTreeFunctions{",
            "            func() int { return INF18 },",
            "            func(a, b int) int { return min(a, b) },",
            "        },",
            "    }",
            "}",
            "",
            "// initは[0, n)のsegment treeを初期化します。",
            "// 各要素の値は単位元となります。",
            "// tested:",
            "//   https://atcoder.jp/contests/abl/tasks/abl_d",
            "func (st *SegmentTree) init(n int) {",
            "    // xはn*2を超える最小の2べき",
            "    x := 1",
            "    for x/2 < n+1 {",
            "        x *= 2",
            "    }",
            "    st.n = x / 2",
            "    st.nodes = make([]int, x)",
            "    for i := 0; i < x; i++ {",
            "        st.nodes[i] = st.f.e()",
            "    }",
            "}",
            "",
            "// initAsArrayはvalsで配列を初期化します。",
            "// 区間の長さはlen(vals)になります。",
            "// tested:",
            "//   https://judge.yosupo.jp/problem/staticrmq",
            "func (st *SegmentTree) initAsArray(vals []int) {",
            "    n := len(vals)",
            "    // xはn*2を超える最小の2べき",
            "    x := 1",
            "    for x/2 < n {",
            "        x *= 2",
            "    }",
            "    st.n = x / 2",
            "    st.nodes = make([]int, x)",
            "",
            "    for i, v := range vals {",
            "        st.nodes[i+st.n] = v",
            "    }",
            "    for i := st.n - 1; i > 0; i-- {",
            "        st.nodes[i] = st.f.calc(st.nodes[i*2], st.nodes[i*2+1])",
            "    }",
            "}",
            "",
            "// updateはi(0-based)番目の値をvalueに更新します。",
            "// tested:",
            "//   https://atcoder.jp/contests/abl/tasks/abl_d",
            "func (st *SegmentTree) update(i, value int) {",
            "    t := i + st.n",
            "    st.nodes[t] = value",
            "",
            "    for {",
            "        t /= 2",
            "        if t == 0 {",
            "            break",
            "        }",
            "        st.nodes[t] = st.f.calc(st.nodes[t*2], st.nodes[t*2+1])",
            "    }",
            "}",
            "",
            "// queryは[l, r) (0-based)の計算値を返します。",
            "// tested:",
            "//   https://atcoder.jp/contests/abl/tasks/abl_d",
            "func (st *SegmentTree) query(l, r int) int {",
            "    ret := st.f.e()",
            "    for ll, rr := l+st.n, r+st.n; ll < rr; ll, rr = ll/2, rr/2 {",
            "        if ll%2 == 1 {",
            "            ret = st.f.calc(ret, st.nodes[ll])",
            "            ll++",
            "        }",
            "        if rr%2 == 1 {",
            "            rr--",
            "            ret = st.f.calc(st.nodes[rr], ret)",
            "        }",
            "    }",
            "",
            "    return ret",
            "}",
            "",
            "// getはi番目(0-based)の要素を返します。",
            "func (st *SegmentTree) get(i int) int {",
            "    return st.nodes[i+st.n]",
            "}",
            "",
            "// allは全区間に対する値を返します。",
            "func (st *SegmentTree) all() int {",
            "    return st.nodes[1]",
            "}",
            ""
        ]
    },
    "segment tree / range add point query": {
        "scope": "go",
        "description": "セグメント木。区間更新、一点取得を効率よくおこなうデータ構造。",
        "prefix": ["_segmenttree"],
        "body": [
            "type SegmentTreeFunctions struct {",
            "    // 単位元を返します",
            "    e func() int",
            "    // 計算結果を返します",
            "    calc func(a, b int) int",
            "}",
            "",
            "type SegmentTree struct {",
            "    // このsegment treeが管理するインデックスの範囲。[0, n)を管理する。",
            "    n int",
            "",
            "    // segment treeの各ノードの値を保持する配列",
            "    nodes []int",
            "",
            "    // このsegment treeの値を操作する関数群",
            "    f SegmentTreeFunctions",
            "}",
            "",
            "// NewSegmentTreeは区間和を扱うSegmentTreeを返します。",
            "// tested:",
            "//   https://atcoder.jp/contests/abl/tasks/abl_d",
            "func NewSegmentTree() *SegmentTree {",
            "    return &SegmentTree{",
            "        -1,",
            "        []int{},",
            "        SegmentTreeFunctions{",
            "            func() int { return 0 },",
            "            func(a, b int) int { return a + b },",
            "        },",
            "    }",
            "}",
            "",
            "// initは[0, n)のsegment treeを初期化します。",
            "// 各要素の値は単位元となります。",
            "// tested:",
            "//   https://atcoder.jp/contests/abl/tasks/abl_d",
            "func (st *SegmentTree) init(n int) {",
            "    // xはn*2を超える最小の2べき",
            "    x := 1",
            "    for x/2 < n+1 {",
            "        x *= 2",
            "    }",
            "    st.n = x / 2",
            "    st.nodes = make([]int, x)",
            "    for i := 0; i < x; i++ {",
            "        st.nodes[i] = st.f.e()",
            "    }",
            "}",
            "",
            "// initAsArrayはvalsで配列を初期化します。",
            "// 区間の長さはlen(vals)になります。",
            "func (st *SegmentTree) initAsArray(vals []int) {",
            "    n := len(vals)",
            "    // xはn*2を超える最小の2べき",
            "    x := 1",
            "    for x/2 < n {",
            "        x *= 2",
            "    }",
            "    st.n = x / 2",
            "    st.nodes = make([]int, x)",
            "",
            "    for i, v := range vals {",
            "        st.nodes[i+st.n] = v",
            "    }",
            "}",
            "",
            "// queryはi(0-based)番目の値を取得します。",
            "// tested:",
            "//   https://atcoder.jp/contests/abc253/tasks/abc253_f",
            "func (st *SegmentTree) query(i int) int {",
            "    t := i + st.n",
            "    ret := st.nodes[t]",
            "",
            "    for {",
            "        t /= 2",
            "        if t == 0 {",
            "            break",
            "        }",
            "        ret = st.f.calc(ret, st.nodes[t])",
            "    }",
            "}",
            "",
            "// updateは[l, r) (0-based)の区間にvalueを適用します。",
            "// tested:",
            "//   https://atcoder.jp/contests/abc253/tasks/abc253_f",
            "func (st *SegmentTree) update(l, r, value int) {",
            "    for ll, rr := l+st.n, r+st.n; ll < rr; ll, rr = ll/2, rr/2 {",
            "        if ll%2 == 1 {",
            "            st.nodes[ll] = st.f.calc(st.nodes[ll], value)",
            "            ll++",
            "        }",
            "        if rr%2 == 1 {",
            "            rr--",
            "            st.nodes[rr] = st.f.calc(st.nodes[rr], value)",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "lazy segment tree": {
        "prefix": ["_lazysegtree", "_lazy"],
        "scope": "go",
        "description": "lazy segment tree",
        "body": [
            "type LazySegmentTree struct {",
            "  // initは長さnの配列として初期化します",
            "  init func(n int) *LazySegmentTree",
            "",
            "  // initByArrayはarrとして初期化します。",
            "  initByArray func(arr []int) *LazySegmentTree",
            "",
            "  // updateは[l, r)をvで更新します。",
            "  update func(l, r, v int)",
            "",
            "  // queryは[l, r)の値を返します。",
            "  query func(l, r int) int",
            "",
            "  // allは全区間の値を返します。",
            "  all func() int",
            "}",
            "",
            "// NewLazySegmentTreeは遅延評価セグメントツリーの実装を返します。",
            "func NewLazySegmentTree(",
            "  operate func(a, b int) int,",
            "  mapping func(f, x int) int,",
            "  composition func(f, g int) int,",
            "  e func() int,",
            "  id func() int,",
            ") *LazySegmentTree {",
            "  st := &LazySegmentTree{}",
            "  var log int",
            "  var size int",
            "  var data []int",
            "  var lazy []int",
            "",
            "  update := func(k int) {",
            "    data[k] = operate(data[k*2+0], data[k*2+1])",
            "  }",
            "",
            "  // 初期化",
            "  // tested:",
            "  //   https://atcoder.jp/contests/typical90/tasks/typical90_ac",
            "  st.init = func(n int) *LazySegmentTree {",
            "    arr := make([]int, n)",
            "    for i := 0; i < n; i++ {",
            "      arr[i] = e()",
            "    }",
            "    return st.initByArray(arr)",
            "  }",
            "",
            "  // 配列による初期化",
            "  // tested:",
            "  //   https://atcoder.jp/contests/typical90/tasks/typical90_ac",
            "  st.initByArray = func(arr []int) *LazySegmentTree {",
            "    n := len(arr)",
            "    size = 1",
            "    log = 0",
            "    for size < n {",
            "      size *= 2",
            "      log++",
            "    }",
            "    data = make([]int, size*2)",
            "    for i := 0; i < n; i++ {",
            "      data[size+i] = arr[i]",
            "    }",
            "    for i := size - 1; i >= 1; i-- {",
            "      update(i)",
            "    }",

            "    lazy = make([]int, size)",
            "    for i := range lazy {",
            "      lazy[i] = id()",
            "    }",
            "",
            "    return st",
            "  }",
            "",
            "  applyAll := func(k int, f int) {",
            "    data[k] = mapping(f, data[k])",
            "    if k < size {",
            "      lazy[k] = composition(f, lazy[k])",
            "    }",
            "  }",
            "  push := func(k int) {",
            "    applyAll(2*k+0, lazy[k])",
            "    applyAll(2*k+1, lazy[k])",
            "    lazy[k] = id()",
            "  }",
            "  // [l, r)の値を取得する。",
            "  // tested:",
            "  //   https://atcoder.jp/contests/typical90/tasks/typical90_ac",
            "  st.query = func(l, r int) int {",
            "    if l == r {",
            "      return e()",
            "    }",
            "    l, r = l+size, r+size",
            "    for i := log; i >= 1; i-- {",
            "      if (l>>i)<<i != l {",
            "        push(l >> i)",
            "      }",
            "      if (r>>i)<<i != r {",
            "        push(r >> i)",
            "      }",
            "    }",
            "    sml, smr := e(), e()",
            "    for l < r {",
            "      if l%2 == 1 {",
            "        sml = operate(sml, data[l])",
            "        l++",
            "      }",
            "      if r%2 == 1 {",
            "        r--",
            "        smr = operate(data[r], smr)",
            "      }",
            "      l >>= 1",
            "      r >>= 1",
            "    }",
            "",
            "    return operate(sml, smr)",
            "  }",
            "",
            "  // [l, r)の値をvで更新する",
            "  // tested:",
            "  //   https://atcoder.jp/contests/typical90/tasks/typical90_ac",
            "  st.update = func(l, r, v int) {",
            "    if l == r {",
            "      return",
            "    }",
            "    l, r = l+size, r+size",
            "    for i := log; i >= 1; i-- {",
            "      if (l>>i)<<i != l {",
            "        push(l >> i)",
            "      }",
            "      if (r>>i)<<i != r {",
            "        push((r - 1) >> i)",
            "      }",
            "    }",
            "    ll, rr := l, r",
            "    for ll < rr {",
            "      if ll%2 == 1 {",
            "        applyAll(ll, v)",
            "        ll++",
            "      }",
            "      if rr%2 == 1 {",
            "        rr--",
            "        applyAll(rr, v)",
            "      }",
            "      ll >>= 1",
            "      rr >>= 1",
            "    }",
            "    for i := 1; i <= log; i++ {",
            "      if (l>>i)<<i != l {",
            "        update(l >> i)",
            "      }",
            "      if (r>>i)<<i != r {",
            "        update((r - 1) >> i)",
            "      }",
            "    }",
            "  }",
            "",
            "  return st",
            "}",
            ""
        ]
    }
}
