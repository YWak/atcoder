{
    "Pair": {
        "scope": "go",
        "description": "ペアの実装",
        "prefix": "_pair",
        "body":[
            "type pair struct {",
            "    a, b int",
            "}",
            "",
            "type pairs []pair",
            "",
            "func (a pairs) Len() int           { return len(a) }",
            "func (a pairs) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }",
            "func (a pairs) Less(i, j int) bool { return a[i].a < a[j].a || a[i].a == a[j].a && a[i].b < a[j].b }",
        ]
    },
    "Treap": {
        "scope": "go",
        "description": "平衝二分探索木によるマップ。",
        "prefix": ["_sortedmap", "_treap", "_treemap"],
        "body": [
            "type Treap struct {",
            "     root       *node",
            "     // allowDup は、このTreapのキーとして重複を許すかどうか",
            "     allowDup   bool",
            "     comparator func(a, b interface{}) int",
            "}",
            "",
            "type node struct {",
            "     key   interface{}",
            "     value interface{}",
            "     pri   int",
            "     cnt   int",
            "     left  *node",
            "     right *node",
            "}",
            "",
            "func NewTreap(comparator func(a, b interface{}) int) *Treap {",
            "     return &Treap{nil, false, comparator}",
            "}",
            "",
            "// NewIntTreap は、int型のキーを使用し、昇順に保存するTreapを作成して返します。",
            "func NewIntTreap() *Treap {",
            "     return NewTreap(func(a, b interface{}) int {",
            "          aa, bb := a.(int), b.(int)",
            "          if aa == bb {",
            "               return 0",
            "          }",
            "          if aa < bb {",
            "               return -1",
            "          }",
            "          return +1",
            "     })",
            "}",
            "// NewRevIntTreap は、int型のキーを使用し、降順に保存するTreapを作成して返します。",
            "func NewRevIntTreap() *Treap {",
            "     return NewTreap(func(a, b interface{}) int {",
            "          aa, bb := a.(int), b.(int)",
            "          if aa == bb {",
            "               return 0",
            "          }",
            "          if aa < bb {",
            "               return +1",
            "          }",
            "          return -1",
            "     })",
            "}",
            "",
            "// Len は、このTreapに含まれる要素の数を返します。",
            "func (t *Treap) Len() int {",
            "     return t._count(t.root)",
            "}",
            "",
            "// Get は、keyに対応する値を探して返します。 存在しない場合はnilを返します。",
            "func (t *Treap) Get(key interface{}) interface{} {",
            "     n := t.root",
            "     for n != nil {",
            "          c := t.comparator(key, n.key)",
            "          if c == 0 {",
            "               return n.value",
            "          } else if c < 0 {",
            "               n = n.left",
            "          } else {",
            "               n = n.right",
            "          }",
            "     }",
            "",
            "     return nil",
            "}",
            "",
            "// GetKthは k (1-indexed)番目のキーと対応する値を返します。",
            "// 該当する要素が存在しない場合は (nil, nil) を返します。",
            "func (t *Treap) GetKth(k int) (interface{}, interface{}) {",
            "     if k < 0 || t.Len() < k {",
            "         return nil, nil",
            "     }",
            "     a, b := t._split(t.root, k)",
            "",
            "     n := a",
            "     var p *node = nil",
            "     for n != nil {",
            "          p = n",
            "          n = n.right",
            "     }",
            "     if p == nil {",
            "          return nil, nil",
            "     }",
            "     t.root = t._merge(a, b)",
            "",
            "     return p.key, p.value",
            "}",
            "",
            "// Find は、key以下で最大のキーを返します。",
            "// 対応するキーがなければnilを返します。",
            "func (t *Treap) Find(key interface{}) interface{} {",
            "     n := t.root",
            "     var ans *node",
            "",
            "     for n != nil {",
            "          c := t.comparator(key, n.key)",
            "          if c == 0 {",
            "               return key",
            "          } else if c < 0 {",
            "               ans = n",
            "               n = n.left",
            "          } else {",
            "               n = n.right",
            "          }",
            "     }",
            "",
            "     if ans == nil {",
            "          return nil",
            "     }",
            "     return ans.key",
            "}",
            "",
            "// Put は、keyとそれに対応するvalueを保存し、古い値を返します。",
            "// すでにキーが登録されている場合、allowDupがtrueなら挿入、falseなら上書きされます。",
            "func (t *Treap) Put(key interface{}, value interface{}) interface{} {",
            "     n, v := t._put(t.root, key, value, rand.Intn(1<<60))",
            "     t.root = n",
            "     t._update(t.root)",
            "",
            "     return v",
            "}",
            "",
            "func (t *Treap) _put(n *node, key, value interface{}, pri int) (*node, interface{}) {",
            "     if n == nil {",
            "          return &node{key, value, pri, 1, nil, nil}, nil",
            "     }",
            "     c := t.comparator(key, n.key)",
            "     if c == 0 && !t.allowDup {",
            "          v := n.value",
            "          n.value = value",
            "          return n, v",
            "     }",
            "     if c <= 0 {",
            "          nn, v := t._put(n.left, key, value, pri)",
            "          n.left = nn",
            "          if n.left.pri < n.pri {",
            "               n = t._rotatel(n)",
            "          }",
            "",
            "          return t._update(n), v",
            "     } else {",
            "          nn, v := t._put(n.right, key, value, pri)",
            "          n.right = nn",
            "          if n.right.pri < n.pri {",
            "               n = t._rotater(n)",
            "          }",
            "          return t._update(n), v",
            "     }",
            "}",
            "",
            "func (t *Treap) _rotatel(n *node) *node {",
            "     result := n.left",
            "     x := result.right",
            "     result.right = n",
            "     n.left = x",
            "     t._update(n)",
            "     t._update(result)",
            "     return result",
            "}",
            "",
            "func (t *Treap) _rotater(n *node) *node {",
            "     result := n.right",
            "     x := result.left",
            "     result.left = n",
            "     n.right = x",
            "     t._update(n)",
            "     t._update(result)",
            "     return result",
            "}",
            "",
            "func (t *Treap) Remove(key interface{}) interface{} {",
            "     n, v := t._remove(t.root, key)",
            "     t.root = t._update(n)",
            "     return v",
            "}",
            "",
            "func (t *Treap) _remove(n *node, key interface{}) (*node, interface{}) {",
            "     if n == nil {",
            "          return nil, nil",
            "     }",
            "     c := t.comparator(key, n.key)",
            "     if c == 0 {",
            "          // このノードを削除する",
            "          v := n.value",
            "          n = t._merge(n.left, n.right)",
            "          t._update(n)",
            "          return n, v",
            "     }",
            "     if c < 0 {",
            "          r := n",
            "          nn, v := t._remove(n.left, key)",
            "          r.left = nn",
            "          if r.left != nil && r.left.pri < r.pri {",
            "               r = t._rotatel(r)",
            "          }",
            "          return t._update(r), v",
            "     } else {",
            "          r := n",
            "          nn, v := t._remove(n.right, key)",
            "          r.right = nn",
            "          if r.right != nil && r.right.pri < r.pri {",
            "               r = t._rotater(r)",
            "          }",
            "          return t._update(r), v",
            "     }",
            "}",
            "",
            "func (t *Treap) _count(n *node) int {",
            "     if n == nil {",
            "          return 0",
            "     }",
            "     return n.cnt",
            "}",
            "",
            "func (t *Treap) _update(n *node) *node {",
            "     if n != nil {",
            "          n.cnt = t._count(n.left) + t._count(n.right) + 1",
            "     }",
            "",
            "     return n",
            "}",
            "",
            "func (t *Treap) _merge(l, r *node) *node {",
            "     if l == nil || r == nil {",
            "          if r == nil {",
            "               return l",
            "          } else {",
            "               return r",
            "          }",
            "     }",
            "     if l.pri < r.pri {",
            "          l.right = t._merge(l.right, r)",
            "          return t._update(l)",
            "     } else {",
            "          r.left = t._merge(l, r.left)",
            "          return t._update(r)",
            "     }",
            "}",
            "",
            "func (t *Treap) _split(n *node, nth int) (*node, *node) {",
            "     if n == nil {",
            "          return nil, nil",
            "     }",
            "     if nth <= t._count(n.left) {",
            "          a, b := t._split(n.left, nth)",
            "          n.left = b",
            "          return a, t._update(n)",
            "     } else {",
            "          a, b := t._split(n.right, nth-t._count(n.left)-1)",
            "          n.right = a",
            "          return t._update(n), b",
            "     }",
            "}",
            ""
        ]
    },
    "PriorityQueueForNumber": {
        "scope": "go",
        "description": "優先度付きキューの実装",
        "prefix": ["_priorityqueue_number"],
        "body": [
            "// PriorityQueueListは優先度付きキューのリストを表す",
            "type PriorityQueueList struct {",
            "  values []int",
            "  prior  func(a, b int) bool",
            "}",
            "",
            "// PriorityQueue は優先度付きキューを表す",
            "type PriorityQueue struct {",
            "  list *PriorityQueueList",
            "}",
            "",
            "// Smaller は aがbより小さいかどうかを判断します。",
            "func Smaller(a, b int) bool {",
            "  return a < b",
            "}",
            "",
            "// Bigger は aがbより大きいかどうかを判断します。",
            "func Bigger(a, b int) bool {",
            "  return b < a",
            "}",
            "",
            "// NewIntPriorityQueue は 優先度をpriorで判断する優先度付きキューを返します。",
            "func NewIntPriorityQueue(prior func(a, b int) bool) PriorityQueue {",
            "  return PriorityQueue{",
            "    &PriorityQueueList{",
            "      make([]int, 0, 100),",
            "      prior,",
            "    },",
            "  }",
            "}",
            "",
            "// Push は優先度付きキューに要素を一つ追加します。",
            "func (pq PriorityQueue) Push(value int) {",
            "  heap.Push(pq.list, value)",
            "}",
            "",
            "// Pop は優先度付きキューから要素を一つ取り出します。",
            "func (pq PriorityQueue) Pop() int {",
            "  return heap.Pop(pq.list).(int)",
            "}",
            "",
            "// Top は優先度つきキューの先頭要素を返します。",
            "func (pq PriorityQueue) Top() int {",
            "  v := heap.Pop(pq.list).(int)",
            "  heap.Push(pq.list, v)",
            "  return v",
            "}",
            "",
            "// Empty は優先度付きキューが空かどうかを判断します。",
            "func (pq PriorityQueue) Empty() bool {",
            "  return pq.list.Len() == 0",
            "}",
            "",
            "// Swap は要素を交換します。",
            "func (list PriorityQueueList) Swap(i, j int) {",
            "  list.values[i], list.values[j] = list.values[j], list.values[i]",
            "}",
            "",
            "// Less は要素を比較し、優先度が低いかどうかを判断します",
            "func (list PriorityQueueList) Less(i, j int) bool {",
            "  return list.prior(list.values[i], list.values[j])",
            "}",
            "",
            "// Len は要素の数を返します。",
            "func (list PriorityQueueList) Len() int {",
            "  return len(list.values)",
            "}",
            "",
            "// Pop は要素を取り出して返します。",
            "func (list *PriorityQueueList) Pop() interface{} {",
            "  old := list.values",
            "  n := len(old)",
            "  item := old[n-1]",
            "  values := old[:n-1]",
            "  list.values = values",
            "  return item",
            "}",
            "",
            "// Push は要素を追加します。",
            "func (list *PriorityQueueList) Push(item interface{}) {",
            "  list.values = append(list.values, item.(int))",
            "}",
        ]
    },
    "PriorityQueueForAny": {
        "scope": "go",
        "description": "優先度付きキューの実装",
        "prefix": ["_priorityqueue_any"],
        "body": [
            "// PriorityQueueListは優先度付きキューのリストを表す",
            "type PriorityQueueList struct {",
            "  values []${1:interface{}}",
            "  prior  func(a, b ${1}) bool",
            "}",
            "",
            "// PriorityQueue は優先度付きキューを表す",
            "type PriorityQueue struct {",
            "  list *PriorityQueueList",
            "}",
            "",
            "// NewPriorityQueue は 優先度をpriorで判断する優先度付きキューを返します。",
            "func NewPriorityQueue(prior func(a, b ${1}) bool) PriorityQueue {",
            "  return PriorityQueue{",
            "    &PriorityQueueList{",
            "      make([]${1}, 0, 100),",
            "      prior,",
            "    },",
            "  }",
            "}",
            "",
            "// Push は優先度付きキューに要素を一つ追加します。",
            "func (pq PriorityQueue) Push(value ${1}) {",
            "  heap.Push(pq.list, value)",
            "}",
            "",
            "// Pop は優先度付きキューから要素を一つ取り出します。",
            "func (pq PriorityQueue) Pop() ${1} {",
            "  return heap.Pop(pq.list).(${1})",
            "}",
            "",
            "// Top は優先度つきキューの先頭要素を返します。",
            "func (pq PriorityQueue) Top() ${1} {",
            "  v := heap.Pop(pq.list).(${1})",
            "  heap.Push(pq.list, v)",
            "  return v",
            "}",
            "",
            "// Empty は優先度付きキューが空かどうかを判断します。",
            "func (pq PriorityQueue) Empty() bool {",
            "  return pq.list.Len() == 0",
            "}",
            "",
            "// Swap は要素を交換します。",
            "func (list PriorityQueueList) Swap(i, j int) {",
            "  list.values[i], list.values[j] = list.values[j], list.values[i]",
            "}",
            "",
            "// Less は要素を比較し、優先度が低いかどうかを判断します",
            "func (list PriorityQueueList) Less(i, j int) bool {",
            "  return list.prior(list.values[i], list.values[j])",
            "}",
            "",
            "// Len は要素の数を返します。",
            "func (list PriorityQueueList) Len() int {",
            "  return len(list.values)",
            "}",
            "",
            "// Pop は要素を取り出して返します。",
            "func (list *PriorityQueueList) Pop() interface{} {",
            "  old := list.values",
            "  n := len(old)",
            "  item := old[n-1]",
            "  values := old[:n-1]",
            "  list.values = values",
            "  return item",
            "}",
            "",
            "// Push は要素を追加します。",
            "func (list *PriorityQueueList) Push(item interface{}) {",
            "  list.values = append(list.values, item.(int))",
            "}",
        ]
    },
    "Union-Find": {
        "scope": "go",
        "description": "Union-Find",
        "prefix": ["_unionfind"],
        "body": [
            "// UnionFind : UnionFind構造を保持する構造体",
            "type UnionFind struct {",
            "    par  []int // i番目のノードに対応する親",
            "}",
            "",
            "// [0, n)のノードを持つUnion-Findを作る",
            "func ufNew(n int) UnionFind {",
            "    uf := UnionFind{par: make([]int, n)}",
            "",
            "    for i := 0; i < n; i++ {",
            "        uf.par[i] = -1",
            "    }",
            "",
            "    return uf",
            "}",
            "",
            "// Root はxのルートを得る",
            "func (uf *UnionFind) Root(x int) int {",
            "    if uf.par[x] < 0 {",
            "        return x",
            "    }",
            "    uf.par[x] = uf.Root(uf.par[x])",
            "    return uf.par[x]",
            "}",
            "",
            "// Unite はxとyを併合する。集合の構造が変更された(== 呼び出し前は異なる集合だった)かどうかを返す",
            "func (uf *UnionFind) Unite(x, y int) bool {",
            "    rx := uf.Root(x)",
            "    ry := uf.Root(y)",
            "",
            "    if rx == ry {",
            "        return false",
            "    }",
            "    if uf.par[rx] > uf.par[ry] {",
            "        rx, ry = ry, rx",
            "    }",
            "    uf.par[rx] += uf.par[ry]",
            "    uf.par[ry] = rx",
            "    return true",
            "}",
            "",
            "// Same はxとyが同じノードにいるかを判断する",
            "func (uf *UnionFind) Same(x, y int) bool {",
            "    rx := uf.Root(x)",
            "    ry := uf.Root(y)",
            "    return rx == ry",
            "}",
            "",
            "// Size は xの集合のサイズを返します。",
            "func (uf *UnionFind) Size(x int) int {",
            "    return -uf.par[uf.Root(x)]",
            "}",
            ""
        ]
    },
    "SegmentTree": {
        "scope": "go",
        "description": "segment tree",
        "prefix": ["_segmenttree"],
        "body": [
            "type SegmentTreeFunctions struct {",
            "    // 単位元を返します",
            "    e func() int",
            "    // 計算結果を返します",
            "    calc func(a, b int) int",
            "}",
            "",
            "type SegmentTree struct {",
            "    // このsegment treeが管理するインデックスの範囲。[0, n)を管理する。",
            "    n int",
            "",
            "    // segment treeの各ノードの値を保持する配列",
            "    nodes []int",
            "",
            "    // このsegment treeの値を操作する関数群",
            "    f SegmentTreeFunctions",
            "}",
            "",
            "// NewSegmentTreeは区間和を扱うSegmentTreeを返します。",
            "// tested:",
            "//   https://atcoder.jp/contests/abl/tasks/abl_d",
            "func NewSegmentTree() *SegmentTree {",
            "    return &SegmentTree{",
            "        -1,",
            "        []int{},",
            "        SegmentTreeFunctions{",
            "            func() int { return 0 },",
            "            func(a, b int) int { return a + b },",
            "        },",
            "    }",
            "}",
            "",
            "// NewRangeMaxQueryは区間最大値を扱うSegmentTreeを返します。",
            "func NewRangeMaxQuery() *SegmentTree {",
            "    return &SegmentTree{",
            "        -1,",
            "        []int{},",
            "        SegmentTreeFunctions{",
            "            func() int { return 0 },",
            "            func(a, b int) int { return max(a, b) },",
            "        },",
            "    }",
            "}",
            "",
            "// NewRangeMinQueryは区間最小値を扱うSegmentTreeを返します。",
            "// tested:",
            "//   https://judge.yosupo.jp/problem/staticrmq",
            "func NewRangeMinQuery() *SegmentTree {",
            "    return &SegmentTree{",
            "        -1,",
            "        []int{},",
            "        SegmentTreeFunctions{",
            "            func() int { return INF18 },",
            "            func(a, b int) int { return min(a, b) },",
            "        },",
            "    }",
            "}",
            "",
            "// initは[0, n)のsegment treeを初期化します。",
            "// 各要素の値は単位元となります。",
            "// tested:",
            "//   https://atcoder.jp/contests/abl/tasks/abl_d",
            "func (st *SegmentTree) init(n int) {",
            "    // xはn*2を超える最小の2べき",
            "    x := 1",
            "    for x/2 < n+1 {",
            "        x *= 2",
            "    }",
            "    st.n = x / 2",
            "    st.nodes = make([]int, x)",
            "    for i := 0; i < x; i++ {",
            "        st.nodes[i] = st.f.e()",
            "    }",
            "}",
            "",
            "// initAsArrayはvalsで配列を初期化します。",
            "// 区間の長さはlen(vals)になります。",
            "// tested:",
            "//   https://judge.yosupo.jp/problem/staticrmq",
            "func (st *SegmentTree) initAsArray(vals []int) {",
            "    n := len(vals)",
            "    // xはn*2を超える最小の2べき",
            "    x := 1",
            "    for x/2 < n {",
            "        x *= 2",
            "    }",
            "    st.n = x / 2",
            "    st.nodes = make([]int, x)",
            "",
            "    for i, v := range vals {",
            "        st.nodes[i+st.n] = v",
            "    }",
            "    for i := st.n - 1; i > 0; i-- {",
            "        st.nodes[i] = st.f.calc(st.nodes[i*2], st.nodes[i*2+1])",
            "    }",
            "}",
            "",
            "// updateはi(0-based)番目の値をvalueに更新します。",
            "// tested:",
            "//   https://atcoder.jp/contests/abl/tasks/abl_d",
            "func (st *SegmentTree) update(i, value int) {",
            "    t := i + st.n",
            "    st.nodes[t] = value",
            "",
            "    for {",
            "        t /= 2",
            "        if t == 0 {",
            "            break",
            "        }",
            "        st.nodes[t] = st.f.calc(st.nodes[t*2], st.nodes[t*2+1])",
            "    }",
            "}",
            "",
            "// queryは[l, r) (0-based)の計算値を返します。",
            "// tested:",
            "//   https://atcoder.jp/contests/abl/tasks/abl_d",
            "func (st *SegmentTree) query(l, r int) int {",
            "    ret := st.f.e()",
            "    for ll, rr := l+st.n, r+st.n; ll < rr; ll, rr = ll/2, rr/2 {",
            "        if ll%2 == 1 {",
            "            ret = st.f.calc(ret, st.nodes[ll])",
            "            ll++",
            "        }",
            "        if rr%2 == 1 {",
            "            rr--",
            "            ret = st.f.calc(st.nodes[rr], ret)",
            "        }",
            "    }",
            "",
            "    return ret",
            "}",
            "",
            "// getはi番目(0-based)の要素を返します。",
            "func (st *SegmentTree) get(i int) int {",
            "    return st.nodes[i+st.n]",
            "}"
        ]
    },
    "binary indexed tree": {
        "scope": "go",
        "prefix": "_binaryindexedtree",
        "description": "Binary Indexed Treeの実装",
        "body": [
            "// BinaryIndexedTree は 1点加算とa1 + a2 + ... + aiを求める",
            "// 1要素分余分に確保すること",
            "type BinaryIndexedTree []int",
            "",
            "// Add はarray[index]にxを加算します",
            "func (bit BinaryIndexedTree) Add(index, x int) {",
            "    for i := index + 1; i < len(bit); i += (i & -i) {",
            "        bit[i] += x",
            "    }",
            "}",
            "",
            "// Sum は array[0]からarray[index]までの総和を取得します。",
            "func (bit BinaryIndexedTree) Sum(index int) int {",
            "    s := 0",
            "    for i := index + 1; i > 0; i -= (i & -i) {",
            "        s += bit[i]",
            "    }",
            "    return s",
            "}"
        ]
    },
    "deque": {
        "description": "dequeueの実装",
        "scope": "go",
        "prefix": "_dequeue",
        "body": [
            "// ${1:Deque}Node は${1}の各要素を保持するstruct",
            "type ${1}Node struct {",
            "    value ${2:int}",
            "    prev  *${1}Node",
            "    next  *${1}Node",
            "}",
            "",
            "// ${1} は両端の操作が可能なキューです",
            "type ${1} struct {",
            "    head     *${1}Node",
            "    tail     *${1}Node",
            "    length   int",
            "    reversed bool",
            "}",
            "",
            "// New${1} は${1}を作成します",
            "func New${1}() ${1} {",
            "    return ${1}{nil, nil, 0, false}",
            "}",
            "",
            "// Len は${1}に含まれる要素の数を取得します",
            "func (deque *${1}) Len() int {",
            "    return deque.length",
            "}",
            "",
            "// PushFront は${1}の先頭に値を追加します。",
            "func (deque *${1}) PushFront(value ${2}) {",
            "    if deque.reversed {",
            "        deque.pushBackInternal(value)",
            "    } else {",
            "        deque.pushFrontInternal(value)",
            "    }",
            "}",
            "",
            "// PushBack は${1}の末尾に値を追加します。",
            "func (deque *${1}) PushBack(value ${2}) {",
            "    if deque.reversed {",
            "        deque.pushFrontInternal(value)",
            "    } else {",
            "        deque.pushBackInternal(value)",
            "    }",
            "}",
            "",
            "// PopFront は${1}の先頭から値を取得し、値を除去します。",
            "func (deque *${1}) PopFront() ${2} {",
            "    if deque.reversed {",
            "        return deque.popBackInternal()",
            "    }",
            "    return deque.popFrontInternal()",
            "}",
            "",
            "// PopBack は${1}の末尾から値を取得し、値を除去します。",
            "func (deque *${1}) PopBack() ${2} {",
            "    if deque.reversed {",
            "        return deque.popFrontInternal()",
            "    }",
            "    return deque.popBackInternal()",
            "}",
            "",
            "// Front は${1}の先頭の値を取得します。",
            "func (deque *${1}) Front() ${2} {",
            "    if deque.reversed {",
            "        return deque.tail.value",
            "    }",
            "    return deque.head.value",
            "}",
            "",
            "// Back は${1}の末尾の値を取得します。",
            "func (deque *${1}) Back() ${2} {",
            "    if deque.reversed {",
            "        return deque.head.value",
            "    }",
            "    return deque.tail.value",
            "}",
            "",
            "// Reverse は${1}の順序を逆転します。",
            "func (deque *${1}) Reverse() {",
            "    deque.reversed = !deque.reversed",
            "}",
            "",
            "// ToArray は${1}を配列化します。",
            "func (deque *${1}) ToArray() []${2} {",
            "    ret := make([]${2}, 0, deque.Len())",
            "",
            "    if deque.reversed {",
            "        for p := deque.tail; p != nil; p = p.prev {",
            "            ret = append(ret, p.value)",
            "        }",
            "    } else {",
            "        for p := deque.head; p != nil; p = p.next {",
            "            ret = append(ret, p.value)",
            "        }",
            "    }",
            "    return ret",
            "}",
            "",
            "func (deque *${1}) pushBackInternal(value ${2}) {",
            "    node := ${1}Node{value, deque.tail, nil}",
            "    if deque.tail == nil {",
            "        deque.head = &node",
            "    } else {",
            "        deque.tail.next = &node",
            "    }",
            "    deque.tail = &node",
            "    deque.length++",
            "}",
            "",
            "func (deque *${1}) pushFrontInternal(value ${2}) {",
            "    node := ${1}Node{value, nil, deque.head}",
            "    if deque.head == nil {",
            "        deque.tail = &node",
            "    } else {",
            "        deque.head.prev = &node",
            "    }",
            "    deque.head = &node",
            "    deque.length++",
            "}",
            "",
            "func (deque *${1}) popFrontInternal() ${2} {",
            "    node := deque.head",
            "    deque.head = node.next",
            "    if deque.head == nil {",
            "        deque.tail = nil",
            "    } else {",
            "        deque.head.prev = nil",
            "    }",
            "",
            "    node.prev = nil",
            "    node.next = nil",
            "    deque.length--",
            "    return node.value",
            "}",
            "",
            "func (deque *${1}) popBackInternal() ${2} {",
            "    node := deque.tail",
            "    deque.tail = node.prev",
            "    if deque.tail == nil {",
            "        deque.head = nil",
            "    } else {",
            "        deque.tail.next = nil",
            "    }",
            "",
            "    node.next = nil",
            "    node.prev = nil",
            "    deque.length--",
            "",
            "    return node.value",
            "}"
        ]
    },
    "wavelet matrix": {
        "prefix": "_waveletmatrix",
        "description": "WaveletMatrixは配列にget/rank/kth smallestなどのクエリを高速に実行できるデータ構造です。",
        "body": [
            "type Dictionary []int",
            "",
            "func (d Dictionary) rank0(r int) int {",
            "  return r - d[r]",
            "}",
            "",
            "func (d Dictionary) rank1(r int) int {",
            "  return d[r]",
            "}",
            "",
            "type WaveletMatrix struct {",
            "  values  []int",
            "  index   [][]int",
            "  zeros   []int",
            "  sum     []Dictionary",
            "  start   map[int]int",
            "  bitsize int",
            "}",
            "",
            "// NewWaveletMatrixはarrをもとにしてWaveletMatrixの実装を返します。",
            "func NewWaveletMatrix(arr []int) *WaveletMatrix {",
            "  n := len(arr)",
            "  values1 := make([]int, n)",
            "  values2 := make([]int, n)",
            "",
            "  // 1である最大のbitを取得する",
            "  bitsize := 0",
            "  for i, v := range arr {",
            "    values1[i] = v",
            "    for b := 0; b < 64; b++ {",
            "      if (v >> b) > 0 {",
            "        bitsize = max(bitsize, b+1)",
            "      }",
            "    }",
            "  }",
            "",
            "  index := make([][]int, bitsize)",
            "  sum := make([]Dictionary, bitsize)",
            "  zeros := make([]int, bitsize)",
            "",
            "  for b := bitsize - 1; b >= 0; b-- {",
            "    // インデックスと累積和の更新",
            "    index[b] = make([]int, n)",
            "    sum[b] = make(Dictionary, n+1)",
            "    for i, v := range values1 {",
            "      t := (v >> b) & 1",
            "      if t == 0 {",
            "        zeros[b]++",
            "      }",
            "      index[b][i] = t",
            "      sum[b][i+1] = sum[b][i] + t",
            "    }",
            "",
            "    // 安定ソート",
            "    k := 0",
            "    for i := 0; i < n; i++ {",
            "      if index[b][i] == 0 {",
            "        values2[k] = values1[i]",
            "        k++",
            "      }",
            "    }",
            "    for i := 0; i < n; i++ {",
            "      if index[b][i] == 1 {",
            "        values2[k] = values1[i]",
            "        k++",
            "      }",
            "    }",
            "    values1, values2 = values2, values1",
            "  }",
            "  start := map[int]int{}",
            "  for i := n - 1; i >= 0; i-- {",
            "    start[values1[i]] = i",
            "  }",
            "  return &WaveletMatrix{values1, index, zeros, sum, start, bitsize}",
            "}",
            "",
            "// Getはk(0-indexed)番目の要素を返します。",
            "func (w *WaveletMatrix) Get(k int) int {",
            "  v := 0",
            "  i := k",
            "  for b := w.bitsize - 1; b >= 0; b-- {",
            "    t := w.index[b][i]",
            "    v += t << b",
            "    if t == 0 {",
            "      i = w.sum[b].rank0(i)",
            "    } else {",
            "      i = w.zeros[b] + w.sum[b].rank1(i)",
            "    }",
            "  }",
            "",
            "  return v",
            "}",
            "",
            "// Rankは区間[0, r)に含まれるxの個数を返します。",
            "// tested:",
            "//   https://atcoder.jp/contests/abc248/tasks/abc248_d",
            "func (w *WaveletMatrix) Rank(x, r int) int {",
            "  if x > (1 << (w.bitsize + 1)) {",
            "    return 0",
            "  }",
            "",
            "  i := r",
            "  for b := w.bitsize - 1; b >= 0; b-- {",
            "    if (x>>b)&1 == 0 {",
            "      i = w.sum[b].rank0(i)",
            "    } else {",
            "      i = w.zeros[b] + w.sum[b].rank1(i)",
            "    }",
            "  }",
            "",
            "  return i - w.start[x]",
            "}",
            "",
            "// KthSmallestは区間[l, r)に含まれる要素のうちk番目(0-indexed)に小さいものを返します。",
            "// tested:",
            "//   https://judge.yosupo.jp/problem/range_kth_smallest",
            "func (w *WaveletMatrix) KthSmallest(l, r, k int) int {",
            "  if l < 0 || l >= len(w.index[0]) || r < 0 || r > len(w.index[0]) {",
            "    panic(fmt.Sprintf(\"invalid range [%d, %d)\", l, r))",
            "  }",
            "",
            "  v := 0",
            "  for b := w.bitsize - 1; b >= 0; b-- {",
            "    c0 := w.sum[b].rank0(r) - w.sum[b].rank0(l)",
            "",
            "    if c0 > k {",
            "      // 0の行き先を探す",
            "      l = w.sum[b].rank0(l)",
            "      r = w.sum[b].rank0(r)",
            "    } else {",
            "      // 1の行き先を探す",
            "      l = w.zeros[b] + w.sum[b].rank1(l)",
            "      r = w.zeros[b] + w.sum[b].rank1(r)",
            "      k = k - c0",
            "      v += (1 << b)",
            "    }",
            "  }",
            "",
            "  return v",
            "}",
            "",
            "// KthLargestは区間[l, r)に含まれる要素のうちk番目(0-indexed)に大きいものを返します。",
            "// tested:",
            "//   https://atcoder.jp/contests/abc239/tasks/abc239_e",
            "func (w *WaveletMatrix) KthLargest(l, r, k int) int {",
            "  return w.KthSmallest(l, r, r-l-1-k)",
            "}"
        ]
    }
}
