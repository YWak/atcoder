{
    "Pair": {
        "scope": "go",
        "description": "ペアの実装",
        "prefix": "pair",
        "body":[
            "type pair struct {",
            "    a, b int",
            "}",
            "",
            "type pairs []pair",
            "",
            "func (a pairs) Len() int           { return len(a) }",
            "func (a pairs) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }",
            "func (a pairs) Less(i, j int) bool { return a[i].a < a[j].a || a[i].a == a[j].a && a[i].b < a[j] }",
        ]
    },
    "Priority Queue": {
        "scope": "go",
        "description": "優先度付きキューの実装",
        "prefix": ["priorityqueue"],
        "body": [
            "PQItem は優先度付きキューに保存される要素",
            "type PQItem ${1:int}",
            "// PQList は 優先度付きキューの本体",
            "type PQList []PQItem",
            "// prior は pq[i]の方が優先度が高いかどうかを判断します。",
            "func (pq PQList) prior(i, j int) bool {",
            "    return pq[i] > pq[j] // 大きいもの優先とする",
            "}",
            "",
            "// PriorityQueue は優先度付きキューを表す",
            "type PriorityQueue struct {",
            "    queue *PQList",
            "}",
            "",
            "func pqNew() PriorityQueue {",
            "    l := make(PQList, 0, 100)",
            "    return PriorityQueue{queue: &l}",
            "}",
            "",
            "// Push は優先度付きキューに要素を一つ追加します。",
            "func (pq PriorityQueue) Push(value PQItem) {",
            "    heap.Push(pq.queue, value)",
            "}",
            "",
            "// Pop は優先度付きキューから要素を一つ取り出します。",
            "func (pq PriorityQueue) Pop() PQItem {",
            "    return heap.Pop(pq.queue).(PQItem)",
            "}",
            "",
            "// Empty は優先度付きキューが空かどうかを判断します。",
            "func (pq PriorityQueue) Empty() bool {",
            "    return len(*pq.queue) == 0",
            "}",
            "",
            "// Swap は要素を交換します。",
            "func (pq PQList) Swap(i, j int) {",
            "    pq[i], pq[j] = pq[j], pq[i]",
            "}",
            "// Less は要素を比較し、pq[i] < pq[j]かどうかを判断します",
            "func (pq PQList) Less(i, j int) bool {",
            "    return pq.prior(i, j)",
            "}",
            "// Len は要素の数を返します。",
            "func (pq PQList) Len() int {",
            "    return len(pq)",
            "}",
            "// Pop は要素を取り出して返します。",
            "func (pq *PQList) Pop() interface{} {",
            "    old := *pq",
            "    n := len(old)",
            "    item := old[n-1]",
            "    *pq = old[:n-1]",
            "    return item",
            "}",
            "// Push は要素を追加します。",
            "func (pq *PQList) Push(item interface{}) {",
            "    *pq = append(*pq, item.(PQItem))",
            "}",
            "",
        ]
    },
    "Union-Find": {
        "scope": "go",
        "description": "Union-Find",
        "prefix": ["unionfind"],
        "body": [
            "// UnionFind : UnionFind構造を保持する構造体",
            "type UnionFind struct {",
            "    par  []int // i番目のノードに対応する親",
            "}",
            "",
            "// [0, n)のノードを持つUnion-Findを作る",
            "func ufNew(n int) UnionFind {",
            "    uf := UnionFind{par: make([]int, n)}",
            "",
            "    for i := 0; i < n; i++ {",
            "        uf.par[i] = -1",
            "    }",
            "",
            "    return uf",
            "}",
            "",
            "// Root はxのルートを得る",
            "func (uf *UnionFind) Root(x int) int {",
            "    if uf.par[x] < 0 {",
            "        return x",
            "    }",
            "    uf.par[x] = uf.Root(uf.par[x])",
            "    return uf.par[x]",
            "}",
            "",
            "// Unite はxとyを併合する。集合の構造が変更された(== 呼び出し前は異なる集合だった)かどうかを返す",
            "func (uf *UnionFind) Unite(x, y int) bool {",
            "    rx := uf.Root(x)",
            "    ry := uf.Root(y)",
            "",
            "    if rx == ry {",
            "        return false",
            "    }",
            "    if uf.par[rx] > uf.par[ry] {",
            "        rx, ry = ry, rx",
            "    }",
            "    uf.par[rx] += uf.par[ry]",
            "    uf.par[ry] = rx",
            "    return true",
            "}",
            "",
            "// Same はxとyが同じノードにいるかを判断する",
            "func (uf *UnionFind) Same(x, y int) bool {",
            "    rx := uf.Root(x)",
            "    ry := uf.Root(y)",
            "    return rx == ry",
            "}",
            "",
            "// Size は xの集合のサイズを返します。",
            "func (uf *UnionFind) Size(x int) int {",
            "    return -uf.par[uf.Root(x)]",
            "}",
            ""
        ]
    },
    "SegmentTree": {
        "scope": "go",
        "description": "segment tree",
        "prefix": ["segmenttree"],
        "body": [
            "type ${1:SegmentTree} []${2:int}",
            "",
            "// Init は セグメントツリーの初期化を行います。",
            "func (st *${1}) Init() {",
            "    n := len(*st)",
            "    x := 1",
            "    for x < n {",
            "        x *= 2",
            "    }",
            "",
            "    arr := make(${1}, x*2)",
            "    for i := 0; i < x*2-1; i++ {",
            "        arr[i] = st.E()",
            "    }",
            "",
            "    *st = arr",
            "}",
            "",
            "// E は セグメントツリーの単位元を返します。",
            "func (st ${1}) E() ${2} {",
            "    return ${3:0}",
            "}",
            "",
            "// Operate は セグメントツリーで適用する演算を定義します。",
            "func (st ${1}) Operate(a, b ${2}) ${2} {",
            "    return ${4:a + b}",
            "}",
            "",
            "// Update は セグメントツリーの i 番目の値を value に設定します。",
            "func (st ${1}) Update(i int, value ${2}) {",
            "    i += len(st)/2 - 1",
            "    st[i] = value",
            "    for i > 0 {",
            "        i = (i - 1) / 2",
            "        st[i] = st.Operate(st[i*2+1], st[i*2+2])",
            "    }",
            "}",
            "",
            "// Query は セグメントツリーの from から to までの値を取得します。",
            "func (st ${1}) Query(from, to int) ${2} {",
            "    return st.query1(from, to, 0, 0, len(st)/2)",
            "}",
            "",
            "func (st ${1}) query1(from, to, k, l, r int) ${2} {",
            "    if r <= from || to <= l {",
            "        return st.E()",
            "    }",
            "    if from <= l && r <= to {",
            "        return st[k]",
            "    }",
            "    m := (l + r) / 2",
            "    vl := st.query1(from, to, k*2+1, l, m)",
            "    vr := st.query1(from, to, k*2+2, m, r)",
            "",
            "    return st.Operate(vl, vr)",
            "}",
            ""
        ]
    },
    "binary indexed tree": {
        "scope": "go",
        "prefix": "binaryindexedtree",
        "description": "Binary Indexed Treeの実装",
        "body": [
            "// BinaryIndexedTree は 1点加算とa1 + a2 + ... + aiを求める",
            "type BinaryIndexedTree []int",
            "",
            "func (bit BinaryIndexedTree) add(index, x int) {",
            "    for i := index + 1; i < len(bit); i += (i & -i) {",
            "        bit[i] += x",
            "    }",
            "}",
            "",
            "func (bit BinaryIndexedTree) sum(index int) int {",
            "    s := 0",
            "    for i := index; i > 0; i -= (i & -i) {",
            "        s += bit[i]",
            "    }",
            "    return s",
            "}"
        ]
    },
    "deque": {
        "description": "dequeueの実装",
        "scope": "go",
        "prefix": "dequeue",
        "body": [
            "// DequeNode はDequeの各要素を保持するstruct",
            "type DequeNode struct {",
            "    value int",
            "    prev  *DequeNode",
            "    next  *DequeNode",
            "}",
            "",
            "// Deque は両端の操作が可能なキューです",
            "type Deque struct {",
            "    head     *DequeNode",
            "    tail     *DequeNode",
            "    length   int",
            "    reversed bool",
            "}",
            "",
            "// NewDeque はDequeを作成します",
            "func NewDeque() Deque {",
            "    return Deque{nil, nil, 0, false}",
            "}",
            "",
            "// Len はDequeに含まれる要素の数を取得します",
            "func (deque *Deque) Len() int {",
            "    return deque.length",
            "}",
            "",
            "// PushFront はDequeの先頭に値を追加します。",
            "func (deque *Deque) PushFront(value int) {",
            "    if deque.reversed {",
            "        _dequePushBackInternal(deque, value)",
            "    } else {",
            "        _dequePushFrontInternal(deque, value)",
            "    }",
            "}",
            "",
            "// PushBack はDequeの末尾に値を追加します。",
            "func (deque *Deque) PushBack(value int) {",
            "    if deque.reversed {",
            "        _dequePushFrontInternal(deque, value)",
            "    } else {",
            "        _dequePushBackInternal(deque, value)",
            "    }",
            "}",
            "",
            "// PopFront はDequeの先頭から値を取得し、値を除去します。",
            "func (deque *Deque) PopFront() int {",
            "    if deque.reversed {",
            "        return _dequePopBackInternal(deque)",
            "    }",
            "    return _dequePopFrontInternal(deque)",
            "}",
            "",
            "// PopBack はDequeの末尾から値を取得し、値を除去します。",
            "func (deque *Deque) PopBack() int {",
            "    if deque.reversed {",
            "        return _dequePopFrontInternal(deque)",
            "    }",
            "    return _dequePopBackInternal(deque)",
            "}",
            "",
            "// PeekFront はDequeの先頭の値を取得します。",
            "func (deque *Deque) PeekFront() int {",
            "    if deque.reversed {",
            "        return deque.tail.value",
            "    }",
            "    return deque.head.value",
            "}",
            "",
            "// PeekBack はDequeの末尾の値を取得します。",
            "func (deque *Deque) PeekBack() int {",
            "    if deque.reversed {",
            "        return deque.head.value",
            "    }",
            "    return deque.tail.value",
            "}",
            "",
            "// Reverse はDequeの順序を逆転します。",
            "func (deque *Deque) Reverse() {",
            "    deque.reversed = !deque.reversed",
            "}",
            "",
            "// ToArray はDequeを配列化します。",
            "func (deque *Deque) ToArray() []int {",
            "    ret := make([]int, 0, deque.Len())",
            "",
            "    if deque.reversed {",
            "        for p := deque.tail; p != nil; p = p.prev {",
            "            ret = append(ret, p.value)",
            "        }",
            "    } else {",
            "        for p := deque.head; p != nil; p = p.next {",
            "            ret = append(ret, p.value)",
            "        }",
            "    }",
            "    return ret",
            "}",
            "",
            "func _dequePushBackInternal(deque *Deque, value int) {",
            "    node := DequeNode{value, deque.tail, nil}",
            "    if deque.tail == nil {",
            "        deque.head = &node",
            "    } else {",
            "        deque.tail.next = &node",
            "    }",
            "    deque.tail = &node",
            "    deque.length++",
            "}",
            "",
            "func _dequePushFrontInternal(deque *Deque, value int) {",
            "    node := DequeNode{value, nil, deque.head}",
            "    if deque.head == nil {",
            "        deque.tail = &node",
            "    } else {",
            "        deque.head.prev = &node",
            "    }",
            "    deque.head = &node",
            "    deque.length++",
            "}",
            "",
            "func _dequePopFrontInternal(deque *Deque) int {",
            "    node := deque.head",
            "    deque.head = node.next",
            "    if deque.head == nil {",
            "        deque.tail = nil",
            "    } else {",
            "        deque.head.prev = nil",
            "    }",
            "",
            "    node.prev = nil",
            "    node.next = nil",
            "    deque.length--",
            "    return node.value",
            "}",
            "",
            "func _dequePopBackInternal(deque *Deque) int {",
            "    node := deque.tail",
            "    deque.tail = node.prev",
            "    if deque.tail == nil {",
            "        deque.head = nil",
            "    } else {",
            "        deque.tail.next = nil",
            "    }",
            "",
            "    node.next = nil",
            "    node.prev = nil",
            "    deque.length--",
            "",
            "    return node.value",
            "}"
        ]
    }
}
