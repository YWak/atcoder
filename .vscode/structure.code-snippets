{
    "Priority Queue": {
        "scope": "go",
        "description": "優先度付きキューの実装",
        "prefix": ["priorityqueue"],
        "body": [
            "// PriorityQueue は優先度付きキューを表す",
            "type PriorityQueue struct {",
            "    queue []${1:int}",
            "    size  int",
            "}",
            "",
            "func pqNew() PriorityQueue {",
            "    return PriorityQueue{queue: make([]${1}, 10), size: 0}",
            "}",
            "func (pq PriorityQueue) less(i, j int) bool {",
            "    return pq.queue[i] < pq.queue[j]",
            "}",
            "",
            "// Push は優先度付きキューに要素を一つ追加します。",
            "func (pq PriorityQueue) Push(value ${1}) {",
            "    if len(pq.queue)-1 == pq.size {",
            "        pq.queue = append(pq.queue, value)",
            "    } else {",
            "        pq.queue[pq.size] = value",
            "    }",
            "",
            "    i := pq.size",
            "    parent := pq.parent(i)",
            "",
            "    for i > 0 && pq.less(parent, i) {",
            "        pq.swap(parent, i)",
            "        i := parent",
            "        parent = pq.parent(i)",
            "    }",
            "",
            "    pq.size++",
            "}",
            "",
            "// Pop は優先度付きキューから要素を一つ取り出します。",
            "func (pq PriorityQueue) Pop() ${1} {",
            "    if pq.size == 0 {",
            "        panic(\"Priority Queue is Empty\")",
            "    }",
            "    ret := pq.queue[0]",
            "    pq.size--",
            "    pq.queue[0] = pq.queue[pq.size]",
            "",
            "    i := 0",
        	"    left := pq.left(i)",
	        "    right := pq.right(i)",
            "",
            "    for right <= pq.size {",
		    "        l := pq.less(i, left)",
		    "        r := pq.less(i, right)",
            "        if l && (!r || pq.less(right, left)) {",
			"            pq.swap(i, left)",
			"            i = left",
		    "        } else if r {",
			"            pq.swap(i, right)",
			"            i = right",
		    "        } else {",
			"            break",
		    "        }",
		    "        left = pq.left(i)",
		    "        right = pq.right(i)",
	        "    }",
            "",
    	    "    return ret",
            "}",
            "",
            "// Empty は優先度付きキューが空かどうかを判断します。",
            "func (pq PriorityQueue) Empty() bool {",
        	"    return pq.size == 0",
            "}",
            "",
            "func (pq PriorityQueue) swap(i, j int) {",
            "    pq.queue[i], pq.queue[j] = pq.queue[j], pq.queue[i]",
            "}",
            "func (pq PriorityQueue) parent(i int) int {",
            "    return (i - 1) / 2",
            "}",
            "func (pq PriorityQueue) left(i int) int {",
        	"    return i*2 + 1",
            "}",
            "func (pq PriorityQueue) right(i int) int {",
    	    "    return i*2 + 2",
            "}",
            "",
        ]
    },
    "Union-Find": {
        "scope": "go",
        "description": "Union-Find",
        "prefix": ["unionfind"],
        "body": [
            "// UnionFind : UnionFind構造を保持する構造体",
            "type UnionFind struct {",
            "    par  []int // i番目のノードに対応する親",
            "    rank []int // i番目のノードの階層",
            "}",
            "",
            "// [0, n)のノードを持つUnion-Findを作る",
            "func ufNew(n int) UnionFind {",
            "    uf := UnionFind{par: make([]int, n), rank: make([]int, n)}",
            "",
            "    for i := 0; i < n; i++ {",
            "        uf.par[i] = i",
            "    }",
            "",
            "    return uf",
            "}",
            "",
            "// Root はxのルートを得る",
            "func (uf *UnionFind) Root(x int) int {",
            "    p := x",
            "    for p != uf.par[p] {",
            "        p = uf.par[p]",
            "    }",
            "    uf.par[x] = p",
            "    return p",
            "}",
            "",
            "// Unite はxとyを併合する。集合の構造が変更された(== 呼び出し前は異なる集合だった)かどうかを返す",
            "func (uf *UnionFind) Unite(x, y int) bool {",
            "    rx := uf.Root(x)",
            "    ry := uf.Root(y)",
            "",
            "    if rx == ry {",
            "        return false",
            "    }",
            "    if uf.rank[rx] < uf.rank[ry] {",
            "        rx, ry = ry, rx",
            "    }",
            "    if uf.rank[rx] == uf.rank[ry] {",
            "        uf.rank[rx]++",
            "    }",
            "    uf.par[ry] = rx",
            "    return true",
            "}",
            "",
            "// Same はxとyが同じノードにいるかを判断する",
            "func (uf *UnionFind) Same(x, y int) bool {",
            "    rx := uf.Root(x)",
            "    ry := uf.Root(y)",
            "    return rx == ry",
            "}",
            ""
        ]
    },
    "graph32": {
        "scope": "go",
        "description": "グラフ - int32",
        "prefix": "graph-list32",
        "body": [
            "type Edge struct {",
            "    left int",
            "    right int",
            "    weight int",
            "}",
            "func generate () Edge {",
            "    left := nextInt()",
            "    right := nextInt()",
            "    weight := 0",
            "    return Edge{ left, right, weight }",
            "}",
            "",
            "func newAdjacencyList(N int, generate func() Edge) [][]*Edge {",
            "    graph := make([][]*Edge, N)",
            "    for i := 0; i < N; i++ {",
            "        e := generate()",
            "        graph[e.left] = append(graph[e.left], &e)",
            "        graph[e.right] = append(graph[e.right], &e)",
            "    }",
            "    return graph",
            "}"
        ]
    },
    "graph64": {
        "scope": "go",
        "description": "グラフ - int32 - 根付き木",
        "prefix": "graph-rooted-tree32",
        "body": [
            "parents := make([]int, ${1:N})",
            "parents[${2:0}] = -1 // 根を設定",
            "parent := ${2}",
            "for i := 0; i < "
        ]
    },
    "graph - int64 - adjacency list": {
        "scope": "go",
        "description": "グラフ - int64 - 隣接リスト",
        "prefix": "graph-list64",
        "body": [
            "graph := make([][]int64, ${1:N})",
            "for i := 0; i < ${1}; i++ {",
            "    ${2:X} := nextInt64()",
            "    ${3:Y} := nextInt64()",
            "    graph[$2] = append(graph[$2], $3)",
            "    graph[$3] = append(graph[$3], $2)",
            "}",
        ]
    },
    "main": {
        "scope": "go",
        "description": "At Coder main テンプレート",
        "prefix": "main",
        "body": [
            "package main",
            "",
            "import (",
            "    \"bufio\"",
            "    \"fmt\"",
            "    \"os\"",
            "    \"strconv\"",
            ")",
            "",
            "func main() {",
            "    $1",
            "    fmt.Println()",
            "}",
            "",
            "var stdin = initStdin()",
            "",
            "func initStdin() *bufio.Scanner {",
        	"    bufsize := 1 * 1024 * 1024 // 1 MB",
    	    "    var stdin = bufio.NewScanner(os.Stdin)",
	        "    stdin.Buffer(make([]byte, bufsize), bufsize)",
	        "    stdin.Split(bufio.ScanWords)",
	        "    return stdin",
            "}",
            "",
            "func nextString() string {",
            "    stdin.Scan()",
	        "    return stdin.Text()",
            "}",
            "",
            "func nextBytes() []byte {",
	        "    stdin.Scan()",
    	    "    return stdin.Bytes()",
            "}",
            "",
            "func nextInt() int {",
            "    i, _ := strconv.Atoi(nextString())",
	        "    return i",
            "}",
            "",
            "func nextInt64() int64 {",
	        "    i, _ := strconv.ParseInt(nextString(), 10, 64)",
            "    return i",
            "}",
            ""
        ]
    }
}
