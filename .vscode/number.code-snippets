{
    "mod operations2": {
        "scope": "go",
        "prefix": "_mod",
        "body": [
            "type Mod struct {",
            "  modulo int",
            "",
            "  // normはaをmod mの値に変換します",
            "  norm func(a int) int",
            "",
            "  // addはa + b (mod m)を返します。",
            "  add func(a, b int) int",
            "",
            "  // subはa - b (mod m)を返します。",
            "  sub func(a, b int) int",
            "",
            "  // mulはa * b (mod m)を返します。",
            "  mul func(a, b int) int",
            "",
            "  // powはa ^ b (mod m)を返します。",
            "  pow func(a, b int) int",
            "",
            "  // invはmod mにおけるaの逆元を返します。",
            "  inv func(a int) int",
            "",
            "  // divはa / b (mod m)を返します。",
            "  div func(a, b int) int",
            "}",
            "func NewMod1000000007() *Mod {",
            "  mod := NewMod(1000000007)",
            "  return mod",
            "}",
            "",
            "func NewMod998244353() *Mod {",
            "  mod := NewMod(998244353)",
            "  return mod",
            "}",
            "",
            "func NewMod(m int) *Mod {",
            "  norm := func(a int) int {",
            "    if a < 0 || a >= m {",
            "      a %= m",
            "    }",
            "    if a < 0 {",
            "      a += m",
            "    }",
            "    return a",
            "  }",
            "  add := func(a, b int) int {",
            "    ab := a + b",
            "    if ab >= m {",
            "      ab %= m",
            "    }",
            "    return ab",
            "  }",
            "  sub := func(a, b int) int {",
            "    ab := a - b + m",
            "    if ab >= m {",
            "      ab -= m",
            "    }",
            "    return ab",
            "  }",
            "  mul := func(a, b int) int {",
            "    return (a * b) % m",
            "  }",
            "  pow := func(a, b int) int {",
            "    ans := 1",
            "",
            "    for b > 0 {",
            "      if b&1 == 1 {",
            "        ans = mul(ans, a)",
            "      }",
            "      a = mul(a, a)",
            "      b = b >> 1",
            "    }",
            "",
            "    return ans",
            "  }",
            "  inv := func(a int) int {",
            "    // 拡張ユークリッドの互除法",
            "    b, u, v := m, 1, 0",
            "    for b > 0 {",
            "      t := a / b",
            "      a -= t * b",
            "      a, b = b, a",
            "      u -= t * v",
            "      u, v = v, u",
            "    }",
            "    return norm(u)",
            "  }",
            "  div := func(a, b int) int {",
            "    return mul(a, inv(b))",
            "  }",
            "",
            "  return &Mod{",
            "    modulo: m,",
            "    norm: norm,",
            "    add:  add,",
            "    sub:  sub,",
            "    mul:  mul,",
            "    pow:  pow,",
            "    inv:  inv,",
            "    div:  div,",
            "  }",
            "}",
        ]
    },
    "combination": {
        "scope": "go",
        "prefix": "_combination",
        "description": "組み合わせの実装",
        "body": [
            "type Combination struct {",
            "  mod   *Mod",
            "  style int",
            "  fact  []int",
            "  ifact []int",
            "  dp    [][]int",
            "}",
            "",
            "func NewComination(n, k int, mod *Mod) Combination {",
            "  c := Combination{mod: mod}",
            "",
            "  if n <= 5000 && k <= 5000 {",
            "    c.style = 1",
            "    // 完全に初期化できる",
            "    c.dp = make([][]int, n+1)",
            "    for i := 0; i <= n; i++ {",
            "      c.dp[i] = make([]int, k+1)",
            "    }",
            "    c.dp[0][0] = 1",
            "    for i := 1; i <= n; i++ {",
            "      c.dp[i][0] = 1",
            "      for j := 1; j <= k; j++ {",
            "        c.dp[i][j] = c.mod.add(c.dp[i-1][j-1], c.dp[i-1][j])",
            "      }",
            "    }",
            "  } else if n <= pow(10, 7) {",
            "    c.style = 2",
            "    c.initFact(n)",
            "  } else if k <= pow(10, 7) {",
            "    c.style = 3",
            "    c.initFact(k)",
            "  }",

            "  return c",
            "}",
            "",
            "func (c *Combination) initFact(n int) {",
            "  N := n + 1",
            "  // 全部の初期化が間に合う",
            "  c.fact = make([]int, N)",
            "  c.ifact = make([]int, N)",

            "  c.fact[1] = 1",
            "  for i := 2; i < N; i++ {",
            "    c.fact[i] = c.mod.mul(c.fact[i-1], i)",
            "  }",
            "  c.ifact[n] = c.mod.inv(c.fact[n])",
            "  for i := n; i > 0; i-- {",
            "    c.ifact[i-1] = c.mod.mul(c.ifact[i], i)",
            "  }",
            "}",
            "",
            "func (c *Combination) nCk(n, k int) int {",
            "  if n <= 0 || k <= 0 || n < k {",
            "    return 1",
            "  }",
            "  switch c.style {",
            "  case 1:",
            "    return c.dp[n][k]",
            "  case 2:",
            "    return c.mod.mul(c.fact[n], c.mod.mul(c.ifact[k], c.ifact[n-k]))",
            "  case 3:",
            "    ans := 1",
            "    for i := n; i >= n-k+1; i-- {",
            "      ans = c.mod.mul(ans, i)",
            "    }",
            "    return c.mod.mul(ans, c.ifact[k])",
            "  default:",
            "    panic(\"not initialized\")",
            "  }",
            "}"
        ]
    },
    "greatest common divider in int": {
        "scope": "go",
        "prefix": "_gcd",
        "description": "最大公約数 gcd(int, int) の実装",
        "body": [
            "func gcd(a, b int) int {",
            "    if b > a {",
            "        a, b = b, a",
            "    }",
            "    for b != 0 {",
            "        a, b = b, a%b",
            "    }",
            "    return a",
            "}",
            ""
        ]
    },
    "least common multiple in int": {
        "scope": "go",
        "prefix": "_lcm",
        "description": "最小公倍数 lcm(int, int)の実装",
        "body": [
            "func lcm(a, b int) int {",
            "    return a * b / gcd(a, b)",
            "}",
            ""
        ]
    },
    "dividers asc int": {
        "scope": "go",
        "prefix": "_dividers-asc",
        "description": "nの全約数(昇順) dividersOf(int)の実装",
        "body": [
            "func dividersOf(n int, direction int) []int {",
            "    div1 := make([]int, 0)",
            "    div2 := make([]int, 0)",
            "",
            "    for i := int(1); i*i <= n; i++ {",
            "        if n % i == 0 {",
            "            div1 = append(div1, i)",
            "",
            "            if i != n/i {",
            "                div2 = append(div2, n/i)",
            "            }",
            "        }",
            "    }",
            "    for i := int(0); i < l; i++ {",
            "        div1 = append(div1, div2[l-1-i])",
            "    }",
            "    return div1",
            "}",
            ""
        ]
    },
    "dividers desc int": {
        "scope": "go",
        "prefix": "_dividers-desc",
        "description": "nの全約数(降順) dividersOf(int)の実装",
        "body": [
            "func dividersOf(n int, direction int) []int {",
            "    div1 := make([]int, 0)",
            "    div2 := make([]int, 0)",
            "",
            "    for i := int(1); i*i <= n; i++ {",
            "        if n % i == 0 {",
            "            div1 = append(div1, i)",
            "",
            "            if i != n/i {",
            "                div2 = append(div2, n/i)",
            "            }",
            "        }",
            "    }",
            "    for i := int(0); i < l; i++ {",
            "        div2 = append(div2, div1[l-1-i])",
            "    }",
            "    return div2",
            "}",
            ""
        ]
    },
    "factorize int": {
        "scope": "go",
        "prefix": ["_factorize", "_primefactorize"],
        "description": "nの素因数分解",
        "body": [
            "// PrimeFactor は素因数と指数",
            "type PrimeFactor struct {",
            "    factor int",
            "    exp    int",
            "}",
            "",
            "func factorize(n int) []PrimeFactor {",
            "    factors := make([]PrimeFactor, 0)",
            "    if n%2 == 0 {",
            "        f := PrimeFactor{2, 0}",
            "        factors = append(factors, f)",
            "",
            "        for n%2 == 0 {",
            "            n /= 2",
            "            f.exp++",
            "        }",
            "    }",
            "    for i := int(3); i*i <= n; i++ {",
            "        if n%i != 0 {",
            "            continue",
            "        }",
            "        f := PrimeFactor{i, 0}",
            "        factors = append(factors, f)",
            "",
            "        for n%i == 0 {",
            "            n /= i",
            "            f.exp++",
            "        }",
            "    }",
            "",
            "    if n != 1 {",
            "        factors = append(factors, PrimeFactor{n, 1})",
            "    }",
            "    return factors",
            "}",
            ""
        ]
    },
    "isPrime int": {
        "scope": "go",
        "prefix": "_isprime",
        "description": "nが素数であるかどうか",
        "body": [
            "func isPrime(n int) bool {",
            "    if n == 2 {",
            "        return true",
            "    } else if n < 3 {",
            "        return false",
            "    }",
            "    for i := int(3); i*i <= n; i++ {",
            "        if n % i == 0 {",
            "            return false",
            "        }",
            "    }",
            "    return true",
            "}",
            ""
        ]
    },
    "Next Permutation": {
        "scope": "go",
        "prefix": "_permutation",
        "body": [
            "type Permutation []int",
            "",
            "func (p *Permutation) next() bool {",
            "    for i := len(*p) - 2; i >= 0; i-- {",
            "        if (*p)[i] > (*p)[i+1] {",
            "            continue",
            "        }",
            "        j := len(*p)",
            "        for {",
            "             j--",
            "             if (*p)[i] < (*p)[j] {",
            "                 break",
            "             }",
            "        }",
            "        (*p)[i], (*p)[j] = (*p)[j], (*p)[i]",
            "        for k, l := i+1, len(*p)-1; k < l; k, l = k+1, l-1 {",
            "            (*p)[k], (*p)[l] = (*p)[l], (*p)[k]",
            "        }",
            "        return true",
            "",
            "    }",
            "    return false",
            "}",
        ]
    },
    "Chinese Remainder Theorem": {
        "scope": "go",
        "prefix": ["_chineseremaindertheorem", "_crt"],
        "description": "中国剰余定理の実装",
        "body": [
            "// crtは中国剰余定理の実装です。",
            "// x = b[i] mod m[i]",
            "// となる x mod lcm(m) を計算し、 x, lcm(m) を返します。",
            "// 解なしの場合は 0, 0を返します。",
            "func crt(b, m []int) (int, int) {",
            "    b0, m0 := 0, 1",
            "    invgcd := func(a, m int) (int, int) {",
            "        x, u := 1, 0",
            "        for m != 0 {",
            "            t := a / m",
            "            a, m = m, a-t*m",
            "            x, u = u, x-t*u",
            "        }",
            "        return a, x",
            "    }",
            "    for i := 0; i < len(b); i++ {",
            "        b1, m1 := b[i], m[i]",
            "        if m0 < m1 {",
            "            b0, b1 = b1, b0",
            "            m0, m1 = m1, m0",
            "        }",
            "        if m0%m1 == 0 {",
            "            if b0%m1 != b1 {",
            "                return 0, 0",
            "            }",
            "            continue",
            "        }",

            "        g, im := invgcd(m0, m1)",
            "        if (b1-b0)%g != 0 {",
            "            return 0, 0",
            "        }",
            "        u := m1 / g",
            "        x := (b1 - b0) / g % u * im % u",
            "        b0 += m0 * x",
            "        m0 *= u",
            "    }",
            "    return (b0%m0 + m0) % m0, m0",
            "}"
        ]
    }
}
